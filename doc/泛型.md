# 泛型 Generics

## 一 泛型是什么

在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件

设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值

其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 U，用于扩展我们定义的 identity 函数：

```ts
/* 应用在函数里 */
function identity <T, U>(value: T, message: U) : T {
  console.log(message);
  return value;
}

console.log(identity<Number, string>(68, "Semlinker"));
```

编译器 自动选择类型

```ts
function identity <T, U>(value: T, message: U) : T {
  console.log(message);
  return value;
}

console.log(identity(68, "Semlinker"));
```

## 二 泛型接口

```ts
interface Person<T, N> {
    name: T;
    value: N
}
function identity<T, U> (value: T, message: U): Identities<T, U> {
  console.log(value + ": " + typeof (value));
  console.log(message + ": " + typeof (message));
  let identities: Identities<T, U> = {
    value,
    message
  };
  return identities;
}

console.log(identity(68, "Semlinker"));
```

## 三 泛型类

在类名后面使用<T>, 定义任意多个类型变量

```ts
interface GenericInterface<U> {
  value: U
  getIdentity: () => U
}

class IdentityClass<T> implements GenericInterface<T> {
  value: T

  constructor(value: T) {
    this.value = value
  }

  getIdentity(): T {
    return this.value
  }

}

const myNumberClass = new IdentityClass<Number>(68);
console.log(myNumberClass.getIdentity()); // 68

const myStringClass = new IdentityClass<string>("Semlinker!");
console.log(myStringClass.getIdentity()); // Semlinker!
```

具体什么时候使用泛型类？

1. 当你的函数、接口或类将处理多种数据类型时；
2. 当函数、接口或类在多个地方使用该数据类型时。

## 四 泛型约束 extends

`T extends Length` 用于告诉编译器，我们支持已经实现 Length 接口的任何类型

之后，当我们使用不含有 length 属性的对象作为参数调用  identity 函数时，
TypeScript 会提示相关的错误信息

我们还可以使用 , 号来分隔多种约束类型，比如：`<T extends Length, Type2, Type3>`

```ts
/* 1 */
interface Length {
  length: number;
}

function identity<T extends Length>(arg: T): T {
  console.log(arg.length); // 可以获取length属性
  return arg;
}
/* 2 设置为数组类型也可以解决上面的问题 */

function identity<T>(arg: T[]): T[] {
   console.log(arg.length);  
   return arg; 
}

// or
function identity<T>(arg: Array<T>): Array<T> {      
  console.log(arg.length);
  return arg; 
}
```

### 检查对象上的键是否存在

keyof 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型

```ts
interface Person {
  name: string;
  age: number;
  location: string;
}

type K1 = keyof Person; // "name" | "age" | "location"
type K2 = keyof Person[];  // number | "length" | "push" | "concat" | ...
type K3 = keyof { [x: string]: Person };  // string | number
```

结合 keyof 使用泛型

```ts
function myFun<T, K extends keyof T> (obj: T, key: K): T[K] {
    return obj[key];
}
```

在以上的 getProperty 函数中，我们通过 K extends keyof T 确保参数 key 一定是对象中含有的键，这样就不会发生运行时错误。这是一个类型安全的解决方案，与简单调用 let value = obj[key]; 不同

## 五 泛型参数默认类型

为泛型中的类型参数，指定默认类型

```ts
interface A<T=string> {
  name: T;
}

const strA: A = { name: "Semlinker" };
const numB: A<number> = { name: 101 };
```

## 六 泛型条件类型 extends

条件类型，会以一个条件表达式进行类型关系检测

下面这个代码的意思是：

如果 T能够赋值给U，那么类型是X，否则是Y

在条件类型表达式中，我们通常还会结合 infer 关键字，实现类型抽取

```ts
T extends U ? X : Y
```




##  参考资料

[一文读懂 TypeScript 泛型及应用](https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&mid=2247484576&idx=1&sn=447d4d12a0c36f6935d7a89e2b6c07b9&chksm=ea47a5f8dd302cee6ac4d57367a347e8ddca5727490484b7d9deac7a6b97728bad99f99ce69c&scene=21#wechat_redirect)




